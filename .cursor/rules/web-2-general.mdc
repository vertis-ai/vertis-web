---
alwaysApply: true
---

# Vertis Web 2 - TanStack Start Project Rules

## Project Overview
This is a TanStack Start application - a full-stack React framework with file-based routing, SSR support, and integrated data fetching. The project uses modern React patterns, TypeScript, Tailwind CSS, and TanStack ecosystem tools.

## Core Technologies & Packages

### Framework & Routing
- **TanStack Start** (`@tanstack/react-start`) - Full-stack React framework
- **TanStack Router** (`@tanstack/react-router`) - File-based routing with SSR support
- **Vite** - Build tool and dev server
- **Nitro** - Deployment adapter (agnostic)

### Data Fetching & API
- **TanStack Query** (`@tanstack/react-query`) - Server state management and data fetching
- **tRPC** (`@trpc/server`, `@trpc/client`, `@trpc/tanstack-react-query`) - End-to-end typesafe APIs
- **SuperJSON** - Enhanced JSON serialization for tRPC

### Forms & Validation
- **TanStack Form** (`@tanstack/react-form`) - Form state management
- **Zod** (`zod`) - Schema validation (v4.x)

### State Management
- **TanStack Store** (`@tanstack/store`, `@tanstack/react-store`) - Client-side state management

### UI & Styling
- **Tailwind CSS** (`tailwindcss`, `@tailwindcss/vite`) - Utility-first CSS (v4.x)
- **Shadcn UI** - Component library built on Radix UI
- **Radix UI** - Headless UI primitives (Label, Select, Slider, Switch, Slot)
- **class-variance-authority** - Component variant management
- **clsx** + **tailwind-merge** - Conditional class name utilities
- **lucide-react** - Icon library

### Tables
- **TanStack Table** (`@tanstack/react-table`) - Headless table library

### Development Tools
- **Biome** (`@biomejs/biome`) - Linting and formatting (replaces ESLint/Prettier)
- **Vitest** - Testing framework
- **TanStack Devtools** - Development tools for Router, Query, and Store

### Utilities
- **@faker-js/faker** - Fake data generation
- **@modelcontextprotocol/sdk** - MCP integration (experimental)

## Code Style & Formatting

### Biome Configuration
- **Linter**: Biome (NOT ESLint)
- **Formatter**: Biome (NOT Prettier)
- **Indentation**: Tabs (not spaces)
- **Quote Style**: Double quotes
- **Semicolons**: Disabled (asNeeded - no semicolons)
- **Line Endings**: Auto-detect
- Run `pnpm check` to lint and format, `pnpm lint` for linting only, `pnpm format` for formatting only

### TypeScript
- **Strict Mode**: Enabled
- **Target**: ES2022
- **Module**: ESNext
- **JSX**: `react-jsx` (React 19+ syntax, no explicit React import needed)
- **Path Aliases**: Use `@/*` for `./src/*` imports
- **Type Safety**: Never use `any` - use `unknown` if type is truly unknown
- **Interfaces vs Types**: Prefer interfaces for object shapes, types for unions/intersections
- **Explicit Return Types**: Use explicit return types for functions, especially public APIs

### Naming Conventions
- **Files**: 
  - Routes: `kebab-case.tsx` (e.g., `user-profile.tsx`)
  - Components: `PascalCase.tsx` (e.g., `UserProfile.tsx`)
  - Utilities: `camelCase.ts` (e.g., `formatDate.ts`)
  - Hooks: `camelCase.ts` with `use` prefix (e.g., `useUserData.ts`)
- **Variables**: `camelCase` for variables and functions, `PascalCase` for components and types
- **Constants**: `UPPER_SNAKE_CASE` for true constants
- **Exports**: Prefer named exports over default exports

## Project Structure

```
src/
├── components/          # React components
│   ├── ui/             # Shadcn UI components ONLY (button, input, label, select, etc.)
│   │                   # These are base UI primitives from Shadcn
│   ├── [feature]/      # Feature-specific composite components
│   │                   # Examples: auth/, reports/, dashboard/
│   │                   # Contains feature-specific pages, forms, and complex components
│   └── [shared]/       # Shared composite components used across features
│                       # Examples: layout/, navigation/, common/
├── routes/             # File-based routes (TanStack Router)
│   ├── __root.tsx      # Root layout route
│   ├── index.tsx       # Home route (/)
│   └── [feature]/      # Feature routes
├── integrations/       # Third-party integrations
│   ├── tanstack-query/ # TanStack Query setup
│   └── trpc/           # tRPC setup (router, client, react hooks)
├── hooks/              # Custom React hooks
│   ├── [feature]/      # Feature-specific hooks (e.g., hooks/auth/, hooks/reports/)
│   └── form/           # Form-related hooks (TanStack Form wrappers)
├── lib/                # Utility functions and shared code
│   ├── auth/           # Auth utilities (route guards, etc.)
│   └── [domain]/       # Domain-specific utilities
├── data/               # Static data, mock data, data fetching functions
├── utils/              # Utility functions (MCP handlers, etc.)
├── styles.css          # Global styles and Tailwind imports
└── router.tsx          # Router configuration

docs/                   # Project documentation
├── ARCHITECTURE_*.md   # Architecture documentation
└── *.md                # Other documentation files
```

### Documentation

- **All documentation files** MUST be placed in the `docs/` directory
- Use descriptive filenames: `ARCHITECTURE_AUTH.md`, `DEPLOYMENT.md`, etc.
- Documentation should be in Markdown format (`.md`)
- Include architecture decisions, implementation details, and migration guides

## Routing (TanStack Router)

### File-Based Routing
- Routes are defined as files in `src/routes/`
- File names map to URL paths: `routes/user/profile.tsx` → `/user/profile`
- **Automatic Route Generation**: TanStack Router automatically generates route files when you create new files in `src/routes/`
- Use `createFileRoute` to define routes (this is the file-based routing pattern):
  ```tsx
  import { createFileRoute } from '@tanstack/react-router'
  
  export const Route = createFileRoute('/user/profile')({
    component: UserProfile,
    loader: async () => {
      // Data fetching before render
      return await fetchUserData()
    },
  })
  ```

### Route Patterns
- **Root Route**: `__root.tsx` - Layout wrapper for all routes
- **Index Route**: `index.tsx` - Home page (`/`)
- **Dynamic Segments**: `[id].tsx` - Dynamic route params (e.g., `[id].tsx` → `/users/:id`)
- **Catch-All**: `$.tsx` - Catch-all routes
- **API Routes**: `api.*.ts` or `api.*.tsx` - API endpoints
- **Nested Routes**: Create subdirectories (e.g., `routes/users/[id]/settings.tsx` → `/users/:id/settings`)

### Route Features
- **Loaders**: Use `loader` for SSR data fetching - runs on server during SSR and on client for client-side navigation
- **Before Load**: Use `beforeLoad` for authentication/redirects
- **Error Components**: Use `errorComponent` for error boundaries
- **Pending Components**: Use `pendingComponent` for loading states
- **Access Loader Data**: `Route.useLoaderData()` in component
- **Loader Example with Typing**:
  ```tsx
  export const Route = createFileRoute('/people')({
    loader: async () => {
      const response = await fetch('https://swapi.dev/api/people')
      return response.json() as Promise<{
        results: {
          name: string
        }[]
      }>
    },
    component: () => {
      const data = Route.useLoaderData()
      return (
        <ul>
          {data.results.map((person) => (
            <li key={person.name}>{person.name}</li>
          ))}
        </ul>
      )
    },
  })
  ```

### Navigation
- Use `Link` component from `@tanstack/react-router` for SPA navigation:
  ```tsx
  import { Link } from '@tanstack/react-router'
  
  // In JSX:
  <Link to="/about">About</Link>
  <Link to="/users/[id]" params={{ id: '123' }}>User Profile</Link>
  ```
- Use `useNavigate` hook for programmatic navigation
- Use `useParams` for route parameters
- Use `useSearch` for query parameters
- Links provide SPA navigation (no full page reload)

### Layouts

**Layout Route Convention** (Similar to Next.js):

TanStack Router supports layout routes using the underscore (`_`) prefix. This is the preferred way to create layouts for groups of routes.

**Key Concepts:**
- `_layoutName.tsx` → Layout component (wraps child routes)
- `_layoutName.childRoute.tsx` → Child route under the layout
- Layouts render `<Outlet />` for child content
- Perfect for authenticated vs public route separation

**Example Structure:**
```
src/routes/
├── __root.tsx                    # Root shell (no conditional logic)
├── _authenticated.tsx            # Layout for authenticated routes
├── _authenticated.index.tsx      # / (with auth + header)
├── _authenticated.profile.tsx    # /profile (with auth + header)
├── login.tsx                     # /login (public, no layout)
└── signup.tsx                    # /signup (public, no layout)
```

**Authenticated Layout Pattern:**
```tsx
import { Outlet, createFileRoute, redirect } from '@tanstack/react-router'
import Header from '@/components/Header'
import { AuthService } from '@/services/authService'

export const Route = createFileRoute('/_authenticated')({
  beforeLoad: ({ location }) => {
    if (typeof window === 'undefined') return
    
    const authenticated = AuthService.isAuthenticated()
    
    if (!authenticated) {
      throw redirect({
        to: '/login',
        search: { redirect: location.pathname },
      })
    }
  },
  component: AuthenticatedLayout,
})

function AuthenticatedLayout() {
  return (
    <>
      <Header />
      <Outlet /> {/* Child routes render here */}
    </>
  )
}
```

**URL Mapping:**
- `_authenticated.index.tsx` → `/` (with layout)
- `_authenticated.profile.tsx` → `/profile` (with layout)
- `_authenticated.settings.account.tsx` → `/settings/account` (with layout)
- `login.tsx` → `/login` (no layout)

**Benefits:**
- ✅ No conditional rendering in root route
- ✅ Declarative structure (file names define behavior)
- ✅ Type-safe route generation
- ✅ Reusable layouts (can create multiple: `_admin`, `_public`, etc.)

## Data Fetching

### Overview
There are multiple ways to fetch data in TanStack Start:
1. **Route Loaders** - Built into TanStack Router for SSR data fetching
2. **TanStack Query** - Client-side data fetching with caching and synchronization
3. **tRPC** - End-to-end typesafe APIs

You can use TanStack Query as an addition or alternative to route loaders. Both approaches work well together.

### TanStack Query (React Query)
- **Provider Setup**: Configured in `src/integrations/tanstack-query/root-provider.tsx`
- **SSR Integration**: Uses `@tanstack/react-router-ssr-query` for SSR support
- **Query Client**: Access via router context (already configured)
- **Devtools**: TanStack Query Devtools are integrated in the root route via `TanStackDevtools`
- **Usage Pattern**:
  ```tsx
  import { useQuery, useMutation } from '@tanstack/react-query'
  
  // Query example
  const { data, isLoading, error } = useQuery({
    queryKey: ['people'],
    queryFn: () =>
      fetch('https://swapi.dev/api/people')
        .then((res) => res.json())
        .then((data) => data.results as { name: string }[]),
    initialData: [], // Optional: provide initial data
  })
  
  // Mutation example
  const { mutate } = useMutation({
    mutationFn: (newTodo: string) =>
      fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo),
      }).then((res) => res.json()),
    onSuccess: () => {
      // Invalidate queries to refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })
  ```
- **When to Use**: TanStack Query is excellent for client-side data fetching, caching, and synchronization
- **Alternative to Loaders**: Can be used as an alternative or complement to route loaders
- **Documentation**: See [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/react/overview)

### tRPC
- **Router Definition**: `src/integrations/trpc/router.ts`
- **Procedures**: Use `publicProcedure` for public endpoints, create protected procedures as needed
- **Validation**: Use Zod schemas with `.input()` for input validation
- **Client Usage**: 
  ```tsx
  import { useTRPC } from '@/integrations/trpc/react'
  
  const trpc = useTRPC()
  const { data } = trpc.todos.list.useQuery()
  const { mutate } = trpc.todos.add.useMutation()
  ```
- **Server-Side**: Use `trpc` from router context in loaders
- **Type Safety**: Export router type: `export type TRPCRouter = typeof trpcRouter`

### Route Loaders (SSR)
- Use loaders for initial data fetching in routes
- Loaders run on server during SSR and on client for client-side navigation
- Access loader data with `Route.useLoaderData()`
- Combine with TanStack Query for optimal caching
- **Benefits**: Loaders simplify data fetching logic and ensure data is available before render
- **Documentation**: See [TanStack Router Loader docs](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#loader-parameters)

## Forms (TanStack Form + Zod)

### Form Validation Pattern
- **ALWAYS use TanStack Form** (`@tanstack/react-form`) for form state management
- **ALWAYS use Zod** (`zod`) for form validation schemas
- TanStack Form has native Zod support - pass Zod schemas directly to validators
- **DO NOT use React Hook Form** - TanStack Form is the standard for this project
- Create custom form hooks in `src/hooks/form/` using `createFormHook` from TanStack Form

### Form Field Components
- Form field components MUST be built using ShadCN UI components from `components/ui/`
- Create form field components that wrap ShadCN components (Input, Label, Select, etc.)
- Form field components should integrate with TanStack Form's field context
- Example pattern: ShadCN Input → Form TextField component → TanStack Form Field

### Form Setup Pattern
```tsx
import { createFormHook } from '@tanstack/react-form'
import { z } from 'zod'
import { TextField, TextArea } from '@/components/[feature]/FormComponents'
import { fieldContext, formContext } from '@/hooks/form/[feature]-form-context'

// Create form hook with field components
export const { useAppForm } = createFormHook({
  fieldComponents: {
    TextField,
    TextArea,
  },
  fieldContext,
  formContext,
})

// Define Zod schema
const schema = z.object({
  title: z.string().min(1, 'Title is required'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

// Use in component
function MyForm() {
  const form = useAppForm({
    defaultValues: {
      title: '',
      email: '',
      password: '',
    },
    validators: {
      onBlur: schema, // Zod schema passed directly
      onChange: schema, // Can also validate on change
    },
    onSubmit: async ({ value }) => {
      // Handle submission - value is typed from Zod schema
      console.log(value)
    },
  })
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault()
      form.handleSubmit()
    }}>
      <form.AppField name="title">
        {(field) => <field.TextField label="Title" />}
      </form.AppField>
      
      <form.AppField name="email">
        {(field) => <field.TextField label="Email" type="email" />}
      </form.AppField>
      
      <form.AppField name="password">
        {(field) => <field.TextField label="Password" type="password" />}
      </form.AppField>
      
      <form.AppForm>
        <form.SubscribeButton label="Submit" />
      </form.AppForm>
    </form>
  )
}
```

### Form Field Component Pattern
```tsx
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { useFieldContext } from '@/hooks/form/[feature]-form-context'
import { useStore } from '@tanstack/react-form'

export function TextField({ label, type = 'text', placeholder }: {
  label: string
  type?: string
  placeholder?: string
}) {
  const field = useFieldContext<string>()
  const errors = useStore(field.store, (state) => state.meta.errors)
  
  return (
    <div className="space-y-2">
      <Label htmlFor={field.name}>{label}</Label>
      <Input
        id={field.name}
        type={type}
        value={field.state.value}
        placeholder={placeholder}
        onBlur={field.handleBlur}
        onChange={(e) => field.handleChange(e.target.value)}
        aria-invalid={errors.length > 0}
      />
      {field.state.meta.isTouched && errors.length > 0 && (
        <div className="text-sm text-destructive">
          {errors.map((error) => (
            <div key={typeof error === 'string' ? error : error.message}>
              {typeof error === 'string' ? error : error.message}
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

## State Management

### TanStack Store
- Use for client-side state that doesn't need server sync
- Create stores in `src/lib/` or feature-specific locations
- **Basic Store Pattern**:
  ```tsx
  import { Store } from '@tanstack/store'
  import { useStore } from '@tanstack/react-store'
  
  const countStore = new Store(0)
  
  function Component() {
    const count = useStore(countStore)
    return (
      <button onClick={() => countStore.setState((n) => n + 1)}>
        Increment - {count}
      </button>
    )
  }
  ```

### Derived State
- Use `Derived` class for computed state that depends on other stores
- Derived state automatically updates when base state changes
- **Important**: Must call `.mount()` on derived stores to start updating
- **Derived Store Pattern**:
  ```tsx
  import { Store, Derived } from '@tanstack/store'
  import { useStore } from '@tanstack/react-store'
  
  const countStore = new Store(0)
  
  // Create derived store
  const doubledStore = new Derived({
    fn: () => countStore.state * 2,
    deps: [countStore], // Dependencies array
  })
  doubledStore.mount() // Required: start the derived store
  
  function Component() {
    const count = useStore(countStore)
    const doubledCount = useStore(doubledStore)
    
    return (
      <>
        <button onClick={() => countStore.setState((n) => n + 1)}>
          Increment - {count}
        </button>
        <div>Doubled - {doubledCount}</div>
      </>
    )
  }
  ```
- **Documentation**: See [TanStack Store docs](https://tanstack.com/store/latest)

## Component Organization & Architecture

### Component Hierarchy

1. **ShadCN UI Components** (`src/components/ui/`)
   - **ONLY** base UI primitives from Shadcn library
   - Examples: `button.tsx`, `input.tsx`, `label.tsx`, `select.tsx`, `textarea.tsx`
   - These are installed via: `pnpx shadcn@latest add [component-name]`
   - **DO NOT** create custom versions of these - use Shadcn components directly
   - **DO NOT** put feature-specific logic in these files
   - These are the building blocks for all other components

2. **Feature Components** (`src/components/[feature]/`)
   - Feature-specific composite components
   - Examples: `components/auth/`, `components/reports/`, `components/dashboard/`
   - Contains:
     - Feature-specific pages/layouts
     - Feature-specific forms (built with ShadCN + TanStack Form)
     - Feature-specific complex components
     - Feature-specific icons/assets
   - **MUST** use ShadCN UI components as building blocks
   - Can create feature-specific form field components that wrap ShadCN components

3. **Shared Components** (`src/components/[shared]/`)
   - Components used across multiple features
   - Examples: `components/layout/`, `components/navigation/`, `components/common/`
   - Only create if component is truly shared across features
   - Prefer feature-specific organization over premature abstraction

### Component Creation Rules

**When to create a new component:**
- Component is reused in multiple places
- Component encapsulates complex logic or UI
- Component represents a distinct feature or domain concept

**When NOT to create a component:**
- Simple one-off UI that won't be reused
- Can be expressed as a simple JSX fragment or inline element
- Premature abstraction before understanding reuse patterns

**Component Naming:**
- Feature components: `PascalCase.tsx` (e.g., `LoginForm.tsx`, `ReportCard.tsx`)
- ShadCN components: `camelCase.tsx` (e.g., `button.tsx`, `input.tsx`) - follows Shadcn convention
- Form field components: `PascalCase.tsx` (e.g., `TextField.tsx`, `PasswordField.tsx`)

### Form Component Organization

**Form Field Components:**
- Create in `src/components/[feature]/FormComponents.tsx` or `src/components/[feature]/form/`
- MUST wrap ShadCN UI components (Input, Label, Select, etc.)
- MUST integrate with TanStack Form field context
- Example: `components/auth/FormComponents.tsx` contains `TextField`, `PasswordField`, etc.

**Form Hooks:**
- Create in `src/hooks/form/[feature]-form.ts`
- Use `createFormHook` from TanStack Form
- Register form field components
- Export `useAppForm` or `use[Feature]Form` hook

**Form Context:**
- Create in `src/hooks/form/[feature]-form-context.ts`
- Export `fieldContext` and `formContext` for TanStack Form integration

### Shadcn UI
- Components are in `src/components/ui/`
- Add new components: `pnpx shadcn@latest add [component-name]`
- Components use `class-variance-authority` for variants
- Use `cn()` utility from `@/lib/utils` for conditional classes
- **ALWAYS prefer ShadCN components** over creating custom UI primitives
- **NEVER** modify ShadCN components directly - extend them via composition

### Icon Standards

**Icon Storage & Organization:**
- **ALWAYS** store custom icons in `src/components/icons/` directory
- **NEVER** use static SVG files in `public/` directory for custom icons
- Use React components for all custom icons exported from Figma
- Export all icons from `src/components/icons/index.ts` for clean imports

**Icon Component Pattern:**
```tsx
import { useId, type SVGProps } from "react"

type Props = SVGProps<SVGSVGElement>

export const IconName = (props: Props) => {
  const clipId = useId() // Use for any IDs (clipPaths, gradients, etc.)
  
  return (
    <svg
      width="32"
      height="32"
      viewBox="0 0 32 32"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-label="Icon description"
      role="img"
      {...props}
    >
      <path
        d="..."
        stroke="currentColor"  // Use currentColor for themeable icons
        fill="currentColor"
        strokeWidth="1.5"
      />
    </svg>
  )
}
```

**Icon Conversion Process:**
1. Export SVG from Figma
2. Convert to React component:
   - Replace hardcoded colors with `currentColor`
   - Replace any `id` attributes with `useId()` hook for uniqueness
   - Add TypeScript types: `type Props = SVGProps<SVGSVGElement>`
   - Add accessibility: `aria-label` and `role="img"`
   - Use prop spreading: `{...props}` for flexibility
3. Place in `src/components/icons/[IconName].tsx`
4. Export from `src/components/icons/index.ts`
5. Import and use: `import { IconName } from "@/components/icons"`

**Icon Usage Rules:**
- **Themeable Colors**: Use `currentColor` instead of hardcoded hex colors for fills and strokes
- **Unique IDs**: Use React's `useId()` hook for any SVG IDs (clipPaths, gradients, masks, filters)
- **Sizing**: Default size in viewBox, allow override via `className` prop (e.g., `w-6 h-6`)
- **Type Safety**: Always extend `SVGProps<SVGSVGElement>` for full prop support
- **Accessibility**: Include `aria-label` and `role="img"` by default

**IconButton Component:**
For consistent icon button styling, use the `IconButton` component from `src/components/common/IconButton.tsx`:

```tsx
import { IconButton } from "@/components/common/IconButton"
import { SettingsIcon } from "@/components/icons"

// Default usage (40x40px, circular, hover bg)
<IconButton aria-label="Settings">
  <SettingsIcon className="w-8 h-8 text-[var(--color-purple-300)]" />
</IconButton>

// Size variants
<IconButton size="sm" aria-label="Close">  {/* 32x32px */}
  <XIcon />
</IconButton>

<IconButton size="lg" aria-label="Menu">   {/* 48x48px */}
  <MenuIcon />
</IconButton>

// Ghost variant (subtle hover)
<IconButton variant="ghost" aria-label="Info">
  <InfoIcon />
</IconButton>
```

**IconButton Features:**
- Always circular (`rounded-full`)
- Pointer cursor on hover
- Consistent hover/active states
- Built-in focus states (accessibility)
- Size variants: `sm` (32px), `md` (40px - default), `lg` (48px)
- Style variants: `default`, `ghost`
- Extends all HTML button attributes

**Why React Components Over Static SVGs:**
- ✅ Bundled with app (no extra HTTP requests)
- ✅ Tree-shaken (unused icons removed)
- ✅ Themeable with CSS variables and `currentColor`
- ✅ Type-safe with full TypeScript support
- ✅ Flexible props (size, color, className)
- ✅ Can add logic, state, or animations
- ✅ Clear ownership and versioning
- ❌ Static SVGs require extra requests, can't be themed, no TypeScript support

**Example Icon Component (SettingsIcon):**
```tsx
import { useId, type SVGProps } from "react"

type Props = SVGProps<SVGSVGElement>

export const SettingsIcon = (props: Props) => {
  const clipId = useId()
  
  return (
    <svg
      width="32"
      height="32"
      viewBox="0 0 32 32"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-label="Settings"
      role="img"
      {...props}
    >
      <g clipPath={`url(#${clipId})`}>
        <path
          d="M13.7667 5.756C..."
          stroke="currentColor"
          strokeWidth="1.5"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </g>
      <defs>
        <clipPath id={clipId}>
          <rect width="32" height="32" rx="16" fill="white" />
        </clipPath>
      </defs>
    </svg>
  )
}
```

### Tailwind CSS
- **Version**: v4.x (via `@tailwindcss/vite`)
- **Configuration**: Defined in `src/styles.css` using `@theme inline` and CSS variables
- **Mobile-First**: Always use mobile-first responsive design
- **Custom Utilities**: Use `@apply` sparingly, prefer utility classes
- **Dark Mode**: Not implemented (dark mode variables are commented out)

### Vertis Design System (Figma Variables)

**Color Naming Convention:**
Our design system uses Figma-exported variables with custom names instead of standard web convention names. Always reference these when styling:

**Primary Colors:**
- `--action-blue: #0030FF` - Primary action color (mapped to `--primary`)
- `--color--white: #FFFFFF` - White background (mapped to `--background`)
- `--color-vertis-purple: #120550` - Deep purple for dark text/backgrounds
- `--color-vertis-purple-lt: #776DA4` - Light purple for medium text

**Purple Scale (UI Grays/Neutrals):**
- `--color-purple-100: #F4F5F9` - Lightest (backgrounds)
- `--color-purple-200: #CDD0E2` - Light (borders, muted)
- `--color-purple-300: #A9ACCA` - Medium light (disabled, secondary text)
- `--color-purple-500: #69679B` - Medium
- `--color-purple-600: #4C4682` - Medium dark
- `--color-purple-800: #120550` - Darkest (same as vertis-purple)

**Semantic Colors:**
- `--color-body-text: #333333` - Default body text color
- `--color-error-red: #D33E3C` - Error states and destructive actions
- `--color-modal: #0B0721` - Modal overlays

**Chart Colors:**
- `--color-chart-blue: #006CA9`
- `--color-chart-green: #BDD740`
- `--color-chart-red: #EB5757`

**Typography Sizes (Figma-exported):**
- `--font-size-h1: 1.375rem` (22px) - Heading 1
- `--font-size-h2: 1.125rem` (18px) - Heading 2
- `--font-size-h3: 1rem` (16px) - Heading 3
- `--font-size-h4: 0.875rem` (14px) - Heading 4
- `--font-size-copy: 0.875rem` (14px) - **Default body text**
- `--font-size-input-label: 0.875rem` (14px) - Input labels
- `--font-size-detail-text: 0.75rem` (12px) - Small text
- `--font-size-detail-text-bold: 0.75rem` (12px) - Small bold text

**Typography Mapped to Tailwind Utilities:**
Figma typography is automatically mapped to Tailwind font size utilities:
- `text-xs` → `--font-size-detail-text` (0.75rem / 12px)
- `text-sm` → `--font-size-input-label` (0.875rem / 14px)
- `text-base` → `--font-size-copy` (0.875rem / 14px) - **Default body text**
- `text-lg` → `--font-size-h3` (1rem / 16px)
- `text-xl` → `--font-size-h2` (1.125rem / 18px)
- `text-2xl` → `--font-size-h1` (1.375rem / 22px)

**Global Typography Styles:**
- Body text defaults to 14px (`--font-size-copy`)
- H1-H4 headings automatically use Figma sizes
- `<p>` tags use body text size (14px)
- `<small>` tags use detail text size (12px)
- `<label>` tags use input label size (14px)

**ShadCN Token Mapping:**
These Figma variables are intelligently mapped to ShadCN design tokens:
- `--primary` → `--action-blue` (Primary blue)
- `--background` → `--color--white` (White)
- `--foreground` → `--color-body-text` (Dark gray text)
- `--destructive` → `--color-error-red` (Red for errors)
- `--border` → `--color-purple-200` (Light purple borders)
- `--muted` → `--color-purple-100` (Light backgrounds)
- `--muted-foreground` → `--color-vertis-purple-lt` (Medium text)

**Usage Examples:**
```tsx
// Use Figma variable names directly
<div className="bg-purple-800 text-white">  {/* Deep purple background */}
<button className="bg-blue-400">           {/* Action blue (primary) */}
<p className="text-purple-300">            {/* Medium light purple text */}

// Or use semantic ShadCN tokens (mapped automatically)
<Button variant="default">                 {/* Uses --primary (action-blue) */}
<Card>                                      {/* Uses --card (white) */}
```

**Important Notes:**
- ❌ Do NOT use standard names like "primary" in variable references - use `--action-blue`
- ❌ Do NOT use "gray" scale - use `--color-purple-*` scale instead
- ✅ Use Figma variable names to maintain consistency with design system
- ✅ Legacy color system is also available (see `@theme inline` in styles.css)

### Component Patterns
- Use Radix UI primitives (via Shadcn) for accessible components
- Compose Shadcn components for complex UIs
- Use `asChild` prop pattern for component composition
- Follow Shadcn's "New York" style (as configured in `components.json`)
- Build feature components by composing ShadCN UI components

### Styling Utilities
- Use `cn()` from `@/lib/utils` for merging Tailwind classes
- Pattern: `cn("base-classes", conditionalClasses, props.className)`
- Use `clsx` for conditional classes, `tailwind-merge` to resolve conflicts

## Tables (TanStack Table)

- Use `@tanstack/react-table` for complex table needs
- Headless library - style with Tailwind
- Follow TanStack Table patterns for sorting, filtering, pagination
- Example data structure in `src/data/demo-table-data.ts`

## Testing

### Vitest
- Test files: `*.test.ts` or `*.test.tsx` (colocated or in `__tests__/`)
- Run tests: `pnpm test`
- Use `@testing-library/react` for component testing
- Use `jsdom` for DOM simulation

### Test Patterns
```tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { MyComponent } from './MyComponent'

describe('MyComponent', () => {
  it('renders correctly', () => {
    render(<MyComponent />)
    expect(screen.getByText('Hello')).toBeInTheDocument()
  })
})
```

## API Routes

### TanStack Start API Routes
- API routes in `src/routes/api.*.ts` or `src/routes/api.*.tsx`
- Use Nitro server functions for API endpoints
- Pattern:
  ```tsx
  import { createFileRoute } from '@tanstack/react-router'
  
  export const Route = createFileRoute('/api/todos')({
    GET: async () => {
      return Response.json({ todos: [] })
    },
    POST: async ({ request }) => {
      const body = await request.json()
      // Handle POST
      return Response.json({ success: true })
    },
  })
  ```

### tRPC API Routes
- tRPC router handles API routes automatically
- Access via `/api/trpc` endpoint
- Use `httpBatchStreamLink` for batching (configured in `src/integrations/trpc/react.ts`)

## Environment & Configuration

### Environment Variables
- Use `.env` files for environment variables
- Access via `process.env` (server-side) or `import.meta.env` (client-side)
- Type-safe env access recommended (create `src/env.ts`)

### Path Aliases
- `@/*` → `./src/*`
- Configured in `tsconfig.json`
- Use for all imports: `import { Button } from '@/components/ui/button'`

## Development Workflow

### Getting Started
- Install dependencies: `pnpm install`
- Start dev server: `pnpm dev` (runs on port 3000)
- Build for production: `pnpm build`
- Preview production build: `pnpm serve`

### Scripts
- `pnpm dev` - Start dev server (port 3000)
- `pnpm build` - Build for production
- `pnpm serve` - Preview production build
- `pnpm test` - Run tests
- `pnpm lint` - Lint code
- `pnpm format` - Format code
- `pnpm check` - Lint and format

### Devtools
- TanStack Router Devtools - Route debugging (integrated in root route)
- TanStack Query Devtools - Query debugging (integrated in root route)
- TanStack Store Devtools - Store debugging (integrated in root route)
- All integrated in root route via `TanStackDevtools` component
- Devtools are automatically available in development mode

## Best Practices

### Component Organization
- **ALWAYS** use ShadCN UI components as the foundation - never create custom UI primitives
- Build feature components by composing ShadCN components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Colocate related files (component, types, utils) in feature folders
- Use composition over configuration
- Organize by feature/domain, not by component type
- Prefer feature-specific organization over shared components until reuse is proven

### Form Best Practices
- **ALWAYS** use TanStack Form + Zod for form validation
- **NEVER** use React Hook Form - TanStack Form is the standard
- Create form field components that wrap ShadCN UI components
- Use Zod schemas for all form validation
- Leverage TanStack Form's built-in Zod integration
- Create feature-specific form hooks using `createFormHook`

### Performance
- Use React.memo() for expensive components
- Leverage TanStack Query caching for data
- Use route loaders for SSR data fetching
- Implement proper loading and error states

### Type Safety
- Leverage TypeScript strict mode
- Use generated types from tRPC
- Type all function parameters and return values
- Avoid `any` - use `unknown` and type guards

### Error Handling
- Use route `errorComponent` for route-level errors
- Implement error boundaries for component errors
- Handle loading and error states in queries
- Provide user-friendly error messages

### Code Quality
- **ALWAYS run `pnpm typecheck`** after making changes to ensure TypeScript types are correct
- **ALWAYS run `pnpm check`** after making changes to ensure no linting or formatting errors
- **NEVER use `any` type** - use proper TypeScript types, `unknown` with type guards, or infer types correctly
- **NEVER use `@ts-ignore` or `@ts-expect-error`** - fix type errors properly instead of suppressing them
- **AVOID type casting** (`as Type`) - prefer proper type inference and type guards
- Write tests for critical functionality
- Keep functions pure when possible
- Use meaningful variable and function names
- Add JSDoc comments for public APIs
- **SVG Accessibility**: All SVG elements MUST have `aria-label` or `title` element for accessibility (Biome A11Y rule)

## MCP Integration (Experimental)

- MCP (Model Context Protocol) is in development
- Handlers in `src/utils/mcp-handler.ts`
- Routes in `src/routes/mcp.ts`
- Note: MCP does not support authentication currently
- Use with caution as API may change

## Demo Files

- Files prefixed with `demo.*` are examples and can be safely deleted
- Reference them for patterns but don't commit demo code to production
- Demo files are provided as starting points to explore installed features
- Examples include: forms, tables, queries, SSR patterns, API routes, and more

## Additional Resources

- **TanStack Documentation**: https://tanstack.com
- **TanStack Router**: https://tanstack.com/router
- **TanStack Query**: https://tanstack.com/query
- **TanStack Form**: https://tanstack.com/form
- **TanStack Store**: https://tanstack.com/store
- **TanStack Table**: https://tanstack.com/table

## Summary: Quick Reference

| Purpose | Location | Pattern |
|---------|----------|---------|
| Routes | `src/routes/` | File-based, `createFileRoute` |
| ShadCN UI Components | `src/components/ui/` | Shadcn primitives only (button, input, label, etc.) |
| Custom Icons | `src/components/icons/` | React components, SVG as TSX, `currentColor`, `useId()` |
| Feature Components | `src/components/[feature]/` | Feature-specific composite components |
| Shared Components | `src/components/[shared]/` | Cross-feature shared components |
| Icon Buttons | `IconButton` component | Circular, consistent hover, pointer cursor |
| Form Field Components | `src/components/[feature]/FormComponents.tsx` | Wrap ShadCN + TanStack Form |
| Hooks | `src/hooks/[feature]/` | `use` prefix, camelCase, organized by feature |
| Form Hooks | `src/hooks/form/[feature]-form.ts` | `createFormHook` with field components |
| Utilities | `src/lib/[domain]/` | camelCase functions, organized by domain |
| Data Fetching | TanStack Query or tRPC | `useQuery`, `trpc.*.useQuery` |
| Forms | TanStack Form + Zod | Feature form hooks, Zod schemas, ShadCN components |
| State | TanStack Store | `src/lib/` or feature folders |
| API Routes | `src/routes/api.*` | TanStack Start or tRPC |
| Types | Colocated with components/hooks | Interfaces preferred |
| Tests | Colocated `*.test.ts` | Vitest + Testing Library |
