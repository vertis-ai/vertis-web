---
alwaysApply: true
---

# Vertis Web 2 - TanStack Start Project Rules

## Project Overview
This is a TanStack Start application - a full-stack React framework with file-based routing, SSR support, and integrated data fetching. The project uses modern React patterns, TypeScript, Tailwind CSS, and TanStack ecosystem tools.

## Core Technologies & Packages

### Framework & Routing
- **TanStack Start** (`@tanstack/react-start`) - Full-stack React framework
- **TanStack Router** (`@tanstack/react-router`) - File-based routing with SSR support
- **Vite** - Build tool and dev server
- **Nitro** - Deployment adapter (agnostic)

### Data Fetching & API
- **TanStack Query** (`@tanstack/react-query`) - Server state management and data fetching
- **tRPC** (`@trpc/server`, `@trpc/client`, `@trpc/tanstack-react-query`) - End-to-end typesafe APIs
- **SuperJSON** - Enhanced JSON serialization for tRPC

### Forms & Validation
- **TanStack Form** (`@tanstack/react-form`) - Form state management
- **Zod** (`zod`) - Schema validation (v4.x)

### State Management
- **TanStack Store** (`@tanstack/store`, `@tanstack/react-store`) - Client-side state management

### UI & Styling
- **Tailwind CSS** (`tailwindcss`, `@tailwindcss/vite`) - Utility-first CSS (v4.x)
- **Shadcn UI** - Component library built on Radix UI
- **Radix UI** - Headless UI primitives (Label, Select, Slider, Switch, Slot)
- **class-variance-authority** - Component variant management
- **clsx** + **tailwind-merge** - Conditional class name utilities
- **lucide-react** - Icon library

### Tables
- **TanStack Table** (`@tanstack/react-table`) - Headless table library

### Development Tools
- **Biome** (`@biomejs/biome`) - Linting and formatting (replaces ESLint/Prettier)
- **Vitest** - Testing framework
- **TanStack Devtools** - Development tools for Router, Query, and Store

### Utilities
- **@faker-js/faker** - Fake data generation
- **@modelcontextprotocol/sdk** - MCP integration (experimental)

## Code Style & Formatting

### Biome Configuration
- **Linter**: Biome (NOT ESLint)
- **Formatter**: Biome (NOT Prettier)
- **Indentation**: Tabs (not spaces)
- **Quote Style**: Double quotes
- **Semicolons**: Disabled (asNeeded - no semicolons)
- **Line Endings**: Auto-detect
- Run `pnpm check` to lint and format, `pnpm lint` for linting only, `pnpm format` for formatting only

### TypeScript
- **Strict Mode**: Enabled
- **Target**: ES2022
- **Module**: ESNext
- **JSX**: `react-jsx` (React 19+ syntax, no explicit React import needed)
- **Path Aliases**: Use `@/*` for `./src/*` imports
- **Type Safety**: Never use `any` - use `unknown` if type is truly unknown
- **Interfaces vs Types**: Prefer interfaces for object shapes, types for unions/intersections
- **Explicit Return Types**: Use explicit return types for functions, especially public APIs

### Naming Conventions
- **Files**: 
  - Routes: `kebab-case.tsx` (e.g., `user-profile.tsx`)
  - Components: `PascalCase.tsx` (e.g., `UserProfile.tsx`)
  - Utilities: `camelCase.ts` (e.g., `formatDate.ts`)
  - Hooks: `camelCase.ts` with `use` prefix (e.g., `useUserData.ts`)
- **Variables**: `camelCase` for variables and functions, `PascalCase` for components and types
- **Constants**: `UPPER_SNAKE_CASE` for true constants
- **Exports**: Prefer named exports over default exports

## Project Structure

```
src/
├── components/          # React components
│   ├── ui/             # Shadcn UI components ONLY (button, input, label, select, etc.)
│   │                   # These are base UI primitives from Shadcn
│   ├── [feature]/      # Feature-specific composite components
│   │                   # Examples: auth/, reports/, dashboard/
│   │                   # Contains feature-specific pages, forms, and complex components
│   └── [shared]/       # Shared composite components used across features
│                       # Examples: layout/, navigation/, common/
├── routes/             # File-based routes (TanStack Router)
│   ├── __root.tsx      # Root layout route
│   ├── index.tsx       # Home route (/)
│   └── [feature]/      # Feature routes
├── integrations/       # Third-party integrations
│   ├── tanstack-query/ # TanStack Query setup
│   └── trpc/           # tRPC setup (router, client, react hooks)
├── hooks/              # Custom React hooks
│   ├── [feature]/      # Feature-specific hooks (e.g., hooks/auth/, hooks/reports/)
│   └── form/           # Form-related hooks (TanStack Form wrappers)
├── lib/                # Utility functions and shared code
│   ├── auth/           # Auth utilities (route guards, etc.)
│   └── [domain]/       # Domain-specific utilities
├── data/               # Static data, mock data, data fetching functions
├── utils/              # Utility functions (MCP handlers, etc.)
├── styles.css          # Global styles and Tailwind imports
└── router.tsx          # Router configuration

docs/                   # Project documentation
├── ARCHITECTURE_*.md   # Architecture documentation
└── *.md                # Other documentation files
```

### Documentation

- **All documentation files** MUST be placed in the `docs/` directory
- Use descriptive filenames: `ARCHITECTURE_AUTH.md`, `DEPLOYMENT.md`, etc.
- Documentation should be in Markdown format (`.md`)
- Include architecture decisions, implementation details, and migration guides

## Routing (TanStack Router)

### File-Based Routing
- Routes are defined as files in `src/routes/`
- File names map to URL paths: `routes/user/profile.tsx` → `/user/profile`
- **Automatic Route Generation**: TanStack Router automatically generates route files when you create new files in `src/routes/`
- Use `createFileRoute` to define routes (this is the file-based routing pattern):
  ```tsx
  import { createFileRoute } from '@tanstack/react-router'
  
  export const Route = createFileRoute('/user/profile')({
    component: UserProfile,
    loader: async () => {
      // Data fetching before render
      return await fetchUserData()
    },
  })
  ```

### Route Patterns
- **Root Route**: `__root.tsx` - Layout wrapper for all routes
- **Index Route**: `index.tsx` - Home page (`/`)
- **Dynamic Segments**: `[id].tsx` - Dynamic route params (e.g., `[id].tsx` → `/users/:id`)
- **Catch-All**: `$.tsx` - Catch-all routes
- **API Routes**: `api.*.ts` or `api.*.tsx` - API endpoints
- **Nested Routes**: Create subdirectories (e.g., `routes/users/[id]/settings.tsx` → `/users/:id/settings`)

### Route Features
- **Loaders**: Use `loader` for SSR data fetching - runs on server during SSR and on client for client-side navigation
- **Before Load**: Use `beforeLoad` for authentication/redirects
- **Error Components**: Use `errorComponent` for error boundaries
- **Pending Components**: Use `pendingComponent` for loading states
- **Access Loader Data**: `Route.useLoaderData()` in component
- **Loader Example with Typing**:
  ```tsx
  export const Route = createFileRoute('/people')({
    loader: async () => {
      const response = await fetch('https://swapi.dev/api/people')
      return response.json() as Promise<{
        results: {
          name: string
        }[]
      }>
    },
    component: () => {
      const data = Route.useLoaderData()
      return (
        <ul>
          {data.results.map((person) => (
            <li key={person.name}>{person.name}</li>
          ))}
        </ul>
      )
    },
  })
  ```

### Navigation
- Use `Link` component from `@tanstack/react-router` for SPA navigation:
  ```tsx
  import { Link } from '@tanstack/react-router'
  
  // In JSX:
  <Link to="/about">About</Link>
  <Link to="/users/[id]" params={{ id: '123' }}>User Profile</Link>
  ```
- Use `useNavigate` hook for programmatic navigation
- Use `useParams` for route parameters
- Use `useSearch` for query parameters
- Links provide SPA navigation (no full page reload)

### Layouts
- Layout is defined in `src/routes/__root.tsx`
- Use `<Outlet />` component to render child route content
- Everything in the root route component appears on all routes
- Example layout pattern:
  ```tsx
  import { Outlet, createRootRoute } from '@tanstack/react-router'
  import { Link } from '@tanstack/react-router'
  
  export const Route = createRootRoute({
    component: () => (
      <>
        <header>
          <nav>
            <Link to="/">Home</Link>
            <Link to="/about">About</Link>
          </nav>
        </header>
        <Outlet /> {/* Child routes render here */}
      </>
    ),
  })
  ```

## Data Fetching

### Overview
There are multiple ways to fetch data in TanStack Start:
1. **Route Loaders** - Built into TanStack Router for SSR data fetching
2. **TanStack Query** - Client-side data fetching with caching and synchronization
3. **tRPC** - End-to-end typesafe APIs

You can use TanStack Query as an addition or alternative to route loaders. Both approaches work well together.

### TanStack Query (React Query)
- **Provider Setup**: Configured in `src/integrations/tanstack-query/root-provider.tsx`
- **SSR Integration**: Uses `@tanstack/react-router-ssr-query` for SSR support
- **Query Client**: Access via router context (already configured)
- **Devtools**: TanStack Query Devtools are integrated in the root route via `TanStackDevtools`
- **Usage Pattern**:
  ```tsx
  import { useQuery, useMutation } from '@tanstack/react-query'
  
  // Query example
  const { data, isLoading, error } = useQuery({
    queryKey: ['people'],
    queryFn: () =>
      fetch('https://swapi.dev/api/people')
        .then((res) => res.json())
        .then((data) => data.results as { name: string }[]),
    initialData: [], // Optional: provide initial data
  })
  
  // Mutation example
  const { mutate } = useMutation({
    mutationFn: (newTodo: string) =>
      fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo),
      }).then((res) => res.json()),
    onSuccess: () => {
      // Invalidate queries to refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })
  ```
- **When to Use**: TanStack Query is excellent for client-side data fetching, caching, and synchronization
- **Alternative to Loaders**: Can be used as an alternative or complement to route loaders
- **Documentation**: See [TanStack Query docs](https://tanstack.com/query/latest/docs/framework/react/overview)

### tRPC
- **Router Definition**: `src/integrations/trpc/router.ts`
- **Procedures**: Use `publicProcedure` for public endpoints, create protected procedures as needed
- **Validation**: Use Zod schemas with `.input()` for input validation
- **Client Usage**: 
  ```tsx
  import { useTRPC } from '@/integrations/trpc/react'
  
  const trpc = useTRPC()
  const { data } = trpc.todos.list.useQuery()
  const { mutate } = trpc.todos.add.useMutation()
  ```
- **Server-Side**: Use `trpc` from router context in loaders
- **Type Safety**: Export router type: `export type TRPCRouter = typeof trpcRouter`

### Route Loaders (SSR)
- Use loaders for initial data fetching in routes
- Loaders run on server during SSR and on client for client-side navigation
- Access loader data with `Route.useLoaderData()`
- Combine with TanStack Query for optimal caching
- **Benefits**: Loaders simplify data fetching logic and ensure data is available before render
- **Documentation**: See [TanStack Router Loader docs](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#loader-parameters)

## Forms (TanStack Form + Zod)

### Form Validation Pattern
- **ALWAYS use TanStack Form** (`@tanstack/react-form`) for form state management
- **ALWAYS use Zod** (`zod`) for form validation schemas
- TanStack Form has native Zod support - pass Zod schemas directly to validators
- **DO NOT use React Hook Form** - TanStack Form is the standard for this project
- Create custom form hooks in `src/hooks/form/` using `createFormHook` from TanStack Form

### Form Field Components
- Form field components MUST be built using ShadCN UI components from `components/ui/`
- Create form field components that wrap ShadCN components (Input, Label, Select, etc.)
- Form field components should integrate with TanStack Form's field context
- Example pattern: ShadCN Input → Form TextField component → TanStack Form Field

### Form Setup Pattern
```tsx
import { createFormHook } from '@tanstack/react-form'
import { z } from 'zod'
import { TextField, TextArea } from '@/components/[feature]/FormComponents'
import { fieldContext, formContext } from '@/hooks/form/[feature]-form-context'

// Create form hook with field components
export const { useAppForm } = createFormHook({
  fieldComponents: {
    TextField,
    TextArea,
  },
  fieldContext,
  formContext,
})

// Define Zod schema
const schema = z.object({
  title: z.string().min(1, 'Title is required'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

// Use in component
function MyForm() {
  const form = useAppForm({
    defaultValues: {
      title: '',
      email: '',
      password: '',
    },
    validators: {
      onBlur: schema, // Zod schema passed directly
      onChange: schema, // Can also validate on change
    },
    onSubmit: async ({ value }) => {
      // Handle submission - value is typed from Zod schema
      console.log(value)
    },
  })
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault()
      form.handleSubmit()
    }}>
      <form.AppField name="title">
        {(field) => <field.TextField label="Title" />}
      </form.AppField>
      
      <form.AppField name="email">
        {(field) => <field.TextField label="Email" type="email" />}
      </form.AppField>
      
      <form.AppField name="password">
        {(field) => <field.TextField label="Password" type="password" />}
      </form.AppField>
      
      <form.AppForm>
        <form.SubscribeButton label="Submit" />
      </form.AppForm>
    </form>
  )
}
```

### Form Field Component Pattern
```tsx
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { useFieldContext } from '@/hooks/form/[feature]-form-context'
import { useStore } from '@tanstack/react-form'

export function TextField({ label, type = 'text', placeholder }: {
  label: string
  type?: string
  placeholder?: string
}) {
  const field = useFieldContext<string>()
  const errors = useStore(field.store, (state) => state.meta.errors)
  
  return (
    <div className="space-y-2">
      <Label htmlFor={field.name}>{label}</Label>
      <Input
        id={field.name}
        type={type}
        value={field.state.value}
        placeholder={placeholder}
        onBlur={field.handleBlur}
        onChange={(e) => field.handleChange(e.target.value)}
        aria-invalid={errors.length > 0}
      />
      {field.state.meta.isTouched && errors.length > 0 && (
        <div className="text-sm text-destructive">
          {errors.map((error) => (
            <div key={typeof error === 'string' ? error : error.message}>
              {typeof error === 'string' ? error : error.message}
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

## State Management

### TanStack Store
- Use for client-side state that doesn't need server sync
- Create stores in `src/lib/` or feature-specific locations
- **Basic Store Pattern**:
  ```tsx
  import { Store } from '@tanstack/store'
  import { useStore } from '@tanstack/react-store'
  
  const countStore = new Store(0)
  
  function Component() {
    const count = useStore(countStore)
    return (
      <button onClick={() => countStore.setState((n) => n + 1)}>
        Increment - {count}
      </button>
    )
  }
  ```

### Derived State
- Use `Derived` class for computed state that depends on other stores
- Derived state automatically updates when base state changes
- **Important**: Must call `.mount()` on derived stores to start updating
- **Derived Store Pattern**:
  ```tsx
  import { Store, Derived } from '@tanstack/store'
  import { useStore } from '@tanstack/react-store'
  
  const countStore = new Store(0)
  
  // Create derived store
  const doubledStore = new Derived({
    fn: () => countStore.state * 2,
    deps: [countStore], // Dependencies array
  })
  doubledStore.mount() // Required: start the derived store
  
  function Component() {
    const count = useStore(countStore)
    const doubledCount = useStore(doubledStore)
    
    return (
      <>
        <button onClick={() => countStore.setState((n) => n + 1)}>
          Increment - {count}
        </button>
        <div>Doubled - {doubledCount}</div>
      </>
    )
  }
  ```
- **Documentation**: See [TanStack Store docs](https://tanstack.com/store/latest)

## Component Organization & Architecture

### Component Hierarchy

1. **ShadCN UI Components** (`src/components/ui/`)
   - **ONLY** base UI primitives from Shadcn library
   - Examples: `button.tsx`, `input.tsx`, `label.tsx`, `select.tsx`, `textarea.tsx`
   - These are installed via: `pnpx shadcn@latest add [component-name]`
   - **DO NOT** create custom versions of these - use Shadcn components directly
   - **DO NOT** put feature-specific logic in these files
   - These are the building blocks for all other components

2. **Feature Components** (`src/components/[feature]/`)
   - Feature-specific composite components
   - Examples: `components/auth/`, `components/reports/`, `components/dashboard/`
   - Contains:
     - Feature-specific pages/layouts
     - Feature-specific forms (built with ShadCN + TanStack Form)
     - Feature-specific complex components
     - Feature-specific icons/assets
   - **MUST** use ShadCN UI components as building blocks
   - Can create feature-specific form field components that wrap ShadCN components

3. **Shared Components** (`src/components/[shared]/`)
   - Components used across multiple features
   - Examples: `components/layout/`, `components/navigation/`, `components/common/`
   - Only create if component is truly shared across features
   - Prefer feature-specific organization over premature abstraction

### Component Creation Rules

**When to create a new component:**
- Component is reused in multiple places
- Component encapsulates complex logic or UI
- Component represents a distinct feature or domain concept

**When NOT to create a component:**
- Simple one-off UI that won't be reused
- Can be expressed as a simple JSX fragment or inline element
- Premature abstraction before understanding reuse patterns

**Component Naming:**
- Feature components: `PascalCase.tsx` (e.g., `LoginForm.tsx`, `ReportCard.tsx`)
- ShadCN components: `camelCase.tsx` (e.g., `button.tsx`, `input.tsx`) - follows Shadcn convention
- Form field components: `PascalCase.tsx` (e.g., `TextField.tsx`, `PasswordField.tsx`)

### Form Component Organization

**Form Field Components:**
- Create in `src/components/[feature]/FormComponents.tsx` or `src/components/[feature]/form/`
- MUST wrap ShadCN UI components (Input, Label, Select, etc.)
- MUST integrate with TanStack Form field context
- Example: `components/auth/FormComponents.tsx` contains `TextField`, `PasswordField`, etc.

**Form Hooks:**
- Create in `src/hooks/form/[feature]-form.ts`
- Use `createFormHook` from TanStack Form
- Register form field components
- Export `useAppForm` or `use[Feature]Form` hook

**Form Context:**
- Create in `src/hooks/form/[feature]-form-context.ts`
- Export `fieldContext` and `formContext` for TanStack Form integration

### Shadcn UI
- Components are in `src/components/ui/`
- Add new components: `pnpx shadcn@latest add [component-name]`
- Components use `class-variance-authority` for variants
- Use `cn()` utility from `@/lib/utils` for conditional classes
- **ALWAYS prefer ShadCN components** over creating custom UI primitives
- **NEVER** modify ShadCN components directly - extend them via composition

### Tailwind CSS
- **Version**: v4.x (via `@tailwindcss/vite`)
- **Configuration**: Inline in `src/styles.css` or `tailwind.config.js`
- **Mobile-First**: Always use mobile-first responsive design
- **Custom Utilities**: Use `@apply` sparingly, prefer utility classes
- **Dark Mode**: Use `dark:` prefix for dark mode styles (if configured)

### Component Patterns
- Use Radix UI primitives (via Shadcn) for accessible components
- Compose Shadcn components for complex UIs
- Use `asChild` prop pattern for component composition
- Follow Shadcn's "New York" style (as configured in `components.json`)
- Build feature components by composing ShadCN UI components

### Styling Utilities
- Use `cn()` from `@/lib/utils` for merging Tailwind classes
- Pattern: `cn("base-classes", conditionalClasses, props.className)`
- Use `clsx` for conditional classes, `tailwind-merge` to resolve conflicts

## Tables (TanStack Table)

- Use `@tanstack/react-table` for complex table needs
- Headless library - style with Tailwind
- Follow TanStack Table patterns for sorting, filtering, pagination
- Example data structure in `src/data/demo-table-data.ts`

## Testing

### Vitest
- Test files: `*.test.ts` or `*.test.tsx` (colocated or in `__tests__/`)
- Run tests: `pnpm test`
- Use `@testing-library/react` for component testing
- Use `jsdom` for DOM simulation

### Test Patterns
```tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { MyComponent } from './MyComponent'

describe('MyComponent', () => {
  it('renders correctly', () => {
    render(<MyComponent />)
    expect(screen.getByText('Hello')).toBeInTheDocument()
  })
})
```

## API Routes

### TanStack Start API Routes
- API routes in `src/routes/api.*.ts` or `src/routes/api.*.tsx`
- Use Nitro server functions for API endpoints
- Pattern:
  ```tsx
  import { createFileRoute } from '@tanstack/react-router'
  
  export const Route = createFileRoute('/api/todos')({
    GET: async () => {
      return Response.json({ todos: [] })
    },
    POST: async ({ request }) => {
      const body = await request.json()
      // Handle POST
      return Response.json({ success: true })
    },
  })
  ```

### tRPC API Routes
- tRPC router handles API routes automatically
- Access via `/api/trpc` endpoint
- Use `httpBatchStreamLink` for batching (configured in `src/integrations/trpc/react.ts`)

## Environment & Configuration

### Environment Variables
- Use `.env` files for environment variables
- Access via `process.env` (server-side) or `import.meta.env` (client-side)
- Type-safe env access recommended (create `src/env.ts`)

### Path Aliases
- `@/*` → `./src/*`
- Configured in `tsconfig.json`
- Use for all imports: `import { Button } from '@/components/ui/button'`

## Development Workflow

### Getting Started
- Install dependencies: `pnpm install`
- Start dev server: `pnpm dev` (runs on port 3000)
- Build for production: `pnpm build`
- Preview production build: `pnpm serve`

### Scripts
- `pnpm dev` - Start dev server (port 3000)
- `pnpm build` - Build for production
- `pnpm serve` - Preview production build
- `pnpm test` - Run tests
- `pnpm lint` - Lint code
- `pnpm format` - Format code
- `pnpm check` - Lint and format

### Devtools
- TanStack Router Devtools - Route debugging (integrated in root route)
- TanStack Query Devtools - Query debugging (integrated in root route)
- TanStack Store Devtools - Store debugging (integrated in root route)
- All integrated in root route via `TanStackDevtools` component
- Devtools are automatically available in development mode

## Best Practices

### Component Organization
- **ALWAYS** use ShadCN UI components as the foundation - never create custom UI primitives
- Build feature components by composing ShadCN components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Colocate related files (component, types, utils) in feature folders
- Use composition over configuration
- Organize by feature/domain, not by component type
- Prefer feature-specific organization over shared components until reuse is proven

### Form Best Practices
- **ALWAYS** use TanStack Form + Zod for form validation
- **NEVER** use React Hook Form - TanStack Form is the standard
- Create form field components that wrap ShadCN UI components
- Use Zod schemas for all form validation
- Leverage TanStack Form's built-in Zod integration
- Create feature-specific form hooks using `createFormHook`

### Performance
- Use React.memo() for expensive components
- Leverage TanStack Query caching for data
- Use route loaders for SSR data fetching
- Implement proper loading and error states

### Type Safety
- Leverage TypeScript strict mode
- Use generated types from tRPC
- Type all function parameters and return values
- Avoid `any` - use `unknown` and type guards

### Error Handling
- Use route `errorComponent` for route-level errors
- Implement error boundaries for component errors
- Handle loading and error states in queries
- Provide user-friendly error messages

### Code Quality
- **ALWAYS run `pnpm typecheck`** after making changes to ensure TypeScript types are correct
- **ALWAYS run `pnpm check`** after making changes to ensure no linting or formatting errors
- **NEVER use `any` type** - use proper TypeScript types, `unknown` with type guards, or infer types correctly
- **NEVER use `@ts-ignore` or `@ts-expect-error`** - fix type errors properly instead of suppressing them
- **AVOID type casting** (`as Type`) - prefer proper type inference and type guards
- Write tests for critical functionality
- Keep functions pure when possible
- Use meaningful variable and function names
- Add JSDoc comments for public APIs
- **SVG Accessibility**: All SVG elements MUST have `aria-label` or `title` element for accessibility (Biome A11Y rule)

## MCP Integration (Experimental)

- MCP (Model Context Protocol) is in development
- Handlers in `src/utils/mcp-handler.ts`
- Routes in `src/routes/mcp.ts`
- Note: MCP does not support authentication currently
- Use with caution as API may change

## Demo Files

- Files prefixed with `demo.*` are examples and can be safely deleted
- Reference them for patterns but don't commit demo code to production
- Demo files are provided as starting points to explore installed features
- Examples include: forms, tables, queries, SSR patterns, API routes, and more

## Additional Resources

- **TanStack Documentation**: https://tanstack.com
- **TanStack Router**: https://tanstack.com/router
- **TanStack Query**: https://tanstack.com/query
- **TanStack Form**: https://tanstack.com/form
- **TanStack Store**: https://tanstack.com/store
- **TanStack Table**: https://tanstack.com/table

## Summary: Quick Reference

| Purpose | Location | Pattern |
|---------|----------|---------|
| Routes | `src/routes/` | File-based, `createFileRoute` |
| ShadCN UI Components | `src/components/ui/` | Shadcn primitives only (button, input, label, etc.) |
| Feature Components | `src/components/[feature]/` | Feature-specific composite components |
| Shared Components | `src/components/[shared]/` | Cross-feature shared components |
| Form Field Components | `src/components/[feature]/FormComponents.tsx` | Wrap ShadCN + TanStack Form |
| Hooks | `src/hooks/[feature]/` | `use` prefix, camelCase, organized by feature |
| Form Hooks | `src/hooks/form/[feature]-form.ts` | `createFormHook` with field components |
| Utilities | `src/lib/[domain]/` | camelCase functions, organized by domain |
| Data Fetching | TanStack Query or tRPC | `useQuery`, `trpc.*.useQuery` |
| Forms | TanStack Form + Zod | Feature form hooks, Zod schemas, ShadCN components |
| State | TanStack Store | `src/lib/` or feature folders |
| API Routes | `src/routes/api.*` | TanStack Start or tRPC |
| Types | Colocated with components/hooks | Interfaces preferred |
| Tests | Colocated `*.test.ts` | Vitest + Testing Library |
